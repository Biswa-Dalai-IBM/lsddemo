/*
 * generated by Xtext 2.38.0
 */
package com.webmethods.flow.serializer;

import com.google.inject.Inject;
import com.webmethods.flow.flowService.BranchProperty;
import com.webmethods.flow.flowService.BranchStep;
import com.webmethods.flow.flowService.CatchProperty;
import com.webmethods.flow.flowService.CatchStep;
import com.webmethods.flow.flowService.CommentProperty;
import com.webmethods.flow.flowService.DropStep;
import com.webmethods.flow.flowService.ExitProperty;
import com.webmethods.flow.flowService.ExitStep;
import com.webmethods.flow.flowService.FinallyProperty;
import com.webmethods.flow.flowService.FinallyStep;
import com.webmethods.flow.flowService.FlowService;
import com.webmethods.flow.flowService.FlowServicePackage;
import com.webmethods.flow.flowService.InvokeStep;
import com.webmethods.flow.flowService.LabelProperty;
import com.webmethods.flow.flowService.LoopProperty;
import com.webmethods.flow.flowService.LoopStep;
import com.webmethods.flow.flowService.MapStep;
import com.webmethods.flow.flowService.MappingBlock;
import com.webmethods.flow.flowService.MappingCopyEntry;
import com.webmethods.flow.flowService.MappingSetEntry;
import com.webmethods.flow.flowService.Model;
import com.webmethods.flow.flowService.QualifiedServiceName;
import com.webmethods.flow.flowService.RepeatProperty;
import com.webmethods.flow.flowService.RepeatStep;
import com.webmethods.flow.flowService.ScopeProperty;
import com.webmethods.flow.flowService.SequenceProperty;
import com.webmethods.flow.flowService.SequenceStep;
import com.webmethods.flow.flowService.TimeoutProperty;
import com.webmethods.flow.flowService.TransformStep;
import com.webmethods.flow.flowService.TryProperty;
import com.webmethods.flow.flowService.TryStep;
import com.webmethods.flow.flowService.ValidateInput;
import com.webmethods.flow.flowService.ValidateOutput;
import com.webmethods.flow.services.FlowServiceGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class FlowServiceSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private FlowServiceGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == FlowServicePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case FlowServicePackage.BRANCH_PROPERTY:
				sequence_BranchProperty(context, (BranchProperty) semanticObject); 
				return; 
			case FlowServicePackage.BRANCH_STEP:
				sequence_BranchStep(context, (BranchStep) semanticObject); 
				return; 
			case FlowServicePackage.CATCH_PROPERTY:
				sequence_CatchProperty(context, (CatchProperty) semanticObject); 
				return; 
			case FlowServicePackage.CATCH_STEP:
				sequence_CatchStep(context, (CatchStep) semanticObject); 
				return; 
			case FlowServicePackage.COMMENT_PROPERTY:
				sequence_CommentProperty(context, (CommentProperty) semanticObject); 
				return; 
			case FlowServicePackage.DROP_STEP:
				sequence_DropStep(context, (DropStep) semanticObject); 
				return; 
			case FlowServicePackage.EXIT_PROPERTY:
				sequence_ExitProperty(context, (ExitProperty) semanticObject); 
				return; 
			case FlowServicePackage.EXIT_STEP:
				sequence_ExitStep(context, (ExitStep) semanticObject); 
				return; 
			case FlowServicePackage.FINALLY_PROPERTY:
				sequence_FinallyProperty(context, (FinallyProperty) semanticObject); 
				return; 
			case FlowServicePackage.FINALLY_STEP:
				sequence_FinallyStep(context, (FinallyStep) semanticObject); 
				return; 
			case FlowServicePackage.FLOW_SERVICE:
				sequence_FlowService(context, (FlowService) semanticObject); 
				return; 
			case FlowServicePackage.INVOKE_STEP:
				sequence_InvokeStep(context, (InvokeStep) semanticObject); 
				return; 
			case FlowServicePackage.LABEL_PROPERTY:
				sequence_LabelProperty(context, (LabelProperty) semanticObject); 
				return; 
			case FlowServicePackage.LOOP_PROPERTY:
				sequence_LoopProperty(context, (LoopProperty) semanticObject); 
				return; 
			case FlowServicePackage.LOOP_STEP:
				sequence_LoopStep(context, (LoopStep) semanticObject); 
				return; 
			case FlowServicePackage.MAP_STEP:
				sequence_MapStep(context, (MapStep) semanticObject); 
				return; 
			case FlowServicePackage.MAPPING_BLOCK:
				sequence_MappingBlock(context, (MappingBlock) semanticObject); 
				return; 
			case FlowServicePackage.MAPPING_COPY_ENTRY:
				sequence_MappingCopyEntry(context, (MappingCopyEntry) semanticObject); 
				return; 
			case FlowServicePackage.MAPPING_SET_ENTRY:
				sequence_MappingSetEntry(context, (MappingSetEntry) semanticObject); 
				return; 
			case FlowServicePackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case FlowServicePackage.QUALIFIED_SERVICE_NAME:
				sequence_QualifiedServiceName(context, (QualifiedServiceName) semanticObject); 
				return; 
			case FlowServicePackage.REPEAT_PROPERTY:
				sequence_RepeatProperty(context, (RepeatProperty) semanticObject); 
				return; 
			case FlowServicePackage.REPEAT_STEP:
				sequence_RepeatStep(context, (RepeatStep) semanticObject); 
				return; 
			case FlowServicePackage.SCOPE_PROPERTY:
				sequence_ScopeProperty(context, (ScopeProperty) semanticObject); 
				return; 
			case FlowServicePackage.SEQUENCE_PROPERTY:
				sequence_SequenceProperty(context, (SequenceProperty) semanticObject); 
				return; 
			case FlowServicePackage.SEQUENCE_STEP:
				sequence_SequenceStep(context, (SequenceStep) semanticObject); 
				return; 
			case FlowServicePackage.TIMEOUT_PROPERTY:
				sequence_TimeoutProperty(context, (TimeoutProperty) semanticObject); 
				return; 
			case FlowServicePackage.TRANSFORM_STEP:
				sequence_TransformStep(context, (TransformStep) semanticObject); 
				return; 
			case FlowServicePackage.TRY_PROPERTY:
				sequence_TryProperty(context, (TryProperty) semanticObject); 
				return; 
			case FlowServicePackage.TRY_STEP:
				sequence_TryStep(context, (TryStep) semanticObject); 
				return; 
			case FlowServicePackage.VALIDATE_INPUT:
				sequence_ValidateInput(context, (ValidateInput) semanticObject); 
				return; 
			case FlowServicePackage.VALIDATE_OUTPUT:
				sequence_ValidateOutput(context, (ValidateOutput) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     BranchProperty returns BranchProperty
	 *
	 * Constraint:
	 *     (switch=STRING | eval=BOOL)
	 * </pre>
	 */
	protected void sequence_BranchProperty(ISerializationContext context, BranchProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Step returns BranchStep
	 *     BranchStep returns BranchStep
	 *
	 * Constraint:
	 *     (properties+=StepProperty* branchProps+=BranchProperty* steps+=Step*)
	 * </pre>
	 */
	protected void sequence_BranchStep(ISerializationContext context, BranchStep semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CatchProperty returns CatchProperty
	 *
	 * Constraint:
	 *     (exit=STRING | failures=STRING | selection=STRING)
	 * </pre>
	 */
	protected void sequence_CatchProperty(ISerializationContext context, CatchProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CatchStep returns CatchStep
	 *
	 * Constraint:
	 *     (properties+=StepProperty* catchProps+=CatchProperty* steps+=Step*)
	 * </pre>
	 */
	protected void sequence_CatchStep(ISerializationContext context, CatchStep semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StepProperty returns CommentProperty
	 *     CommentProperty returns CommentProperty
	 *     MapElement returns CommentProperty
	 *
	 * Constraint:
	 *     value=STRING
	 * </pre>
	 */
	protected void sequence_CommentProperty(ISerializationContext context, CommentProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FlowServicePackage.Literals.COMMENT_PROPERTY__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FlowServicePackage.Literals.COMMENT_PROPERTY__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCommentPropertyAccess().getValueSTRINGTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MapElement returns DropStep
	 *     DropStep returns DropStep
	 *
	 * Constraint:
	 *     (path+=ID path+=ID*)
	 * </pre>
	 */
	protected void sequence_DropStep(ISerializationContext context, DropStep semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExitProperty returns ExitProperty
	 *
	 * Constraint:
	 *     (
	 *         comment=STRING | 
	 *         label=STRING | 
	 *         signal=STRING | 
	 *         failureName=STRING | 
	 *         failureInstance=STRING | 
	 *         exitForm=STRING | 
	 *         failureMessage=STRING
	 *     )
	 * </pre>
	 */
	protected void sequence_ExitProperty(ISerializationContext context, ExitProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Step returns ExitStep
	 *     ExitStep returns ExitStep
	 *
	 * Constraint:
	 *     exitProps+=ExitProperty*
	 * </pre>
	 */
	protected void sequence_ExitStep(ISerializationContext context, ExitStep semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FinallyProperty returns FinallyProperty
	 *
	 * Constraint:
	 *     value=STRING
	 * </pre>
	 */
	protected void sequence_FinallyProperty(ISerializationContext context, FinallyProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FlowServicePackage.Literals.FINALLY_PROPERTY__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FlowServicePackage.Literals.FINALLY_PROPERTY__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFinallyPropertyAccess().getValueSTRINGTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FinallyStep returns FinallyStep
	 *
	 * Constraint:
	 *     (properties+=StepProperty* finalProps+=FinallyProperty* steps+=Step*)
	 * </pre>
	 */
	protected void sequence_FinallyStep(ISerializationContext context, FinallyStep semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FlowService returns FlowService
	 *
	 * Constraint:
	 *     (name=ID steps+=Step*)
	 * </pre>
	 */
	protected void sequence_FlowService(ISerializationContext context, FlowService semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Step returns InvokeStep
	 *     InvokeStep returns InvokeStep
	 *
	 * Constraint:
	 *     (service=QualifiedServiceName properties+=StepProperty* invokeProps+=InvokeProperty* mappings+=MappingBlock*)
	 * </pre>
	 */
	protected void sequence_InvokeStep(ISerializationContext context, InvokeStep semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StepProperty returns LabelProperty
	 *     LabelProperty returns LabelProperty
	 *     MapElement returns LabelProperty
	 *
	 * Constraint:
	 *     value=STRING
	 * </pre>
	 */
	protected void sequence_LabelProperty(ISerializationContext context, LabelProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FlowServicePackage.Literals.LABEL_PROPERTY__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FlowServicePackage.Literals.LABEL_PROPERTY__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLabelPropertyAccess().getValueSTRINGTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LoopProperty returns LoopProperty
	 *
	 * Constraint:
	 *     (input=STRING | output=STRING)
	 * </pre>
	 */
	protected void sequence_LoopProperty(ISerializationContext context, LoopProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Step returns LoopStep
	 *     LoopStep returns LoopStep
	 *
	 * Constraint:
	 *     (properties+=StepProperty* loopProps+=LoopProperty* steps+=Step*)
	 * </pre>
	 */
	protected void sequence_LoopStep(ISerializationContext context, LoopStep semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Step returns MapStep
	 *     MapStep returns MapStep
	 *
	 * Constraint:
	 *     (mapElements+=StepProperty | mapElements+=MappingSetEntry | mapElements+=MappingCopyEntry | mapElements+=TransformStep | mapElements+=DropStep)*
	 * </pre>
	 */
	protected void sequence_MapStep(ISerializationContext context, MapStep semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MappingBlock returns MappingBlock
	 *
	 * Constraint:
	 *     ((direction='input' | direction='output') entries+=MappingCopyEntry? (entries+=MappingSetEntry? entries+=MappingCopyEntry?)*)
	 * </pre>
	 */
	protected void sequence_MappingBlock(ISerializationContext context, MappingBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MapElement returns MappingCopyEntry
	 *     MappingEntry returns MappingCopyEntry
	 *     MappingCopyEntry returns MappingCopyEntry
	 *
	 * Constraint:
	 *     (fromPath+=ID fromPath+=ID* toPath+=ID toPath+=ID*)
	 * </pre>
	 */
	protected void sequence_MappingCopyEntry(ISerializationContext context, MappingCopyEntry semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MapElement returns MappingSetEntry
	 *     MappingEntry returns MappingSetEntry
	 *     MappingSetEntry returns MappingSetEntry
	 *
	 * Constraint:
	 *     (path+=ID path+=ID* value=Value)
	 * </pre>
	 */
	protected void sequence_MappingSetEntry(ISerializationContext context, MappingSetEntry semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     services+=FlowService+
	 * </pre>
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     QualifiedServiceName returns QualifiedServiceName
	 *
	 * Constraint:
	 *     (namespace+=ID namespace+=ID* name=ID)
	 * </pre>
	 */
	protected void sequence_QualifiedServiceName(ISerializationContext context, QualifiedServiceName semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RepeatProperty returns RepeatProperty
	 *
	 * Constraint:
	 *     (count=INT | interval=INT | on=STRING)
	 * </pre>
	 */
	protected void sequence_RepeatProperty(ISerializationContext context, RepeatProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Step returns RepeatStep
	 *     RepeatStep returns RepeatStep
	 *
	 * Constraint:
	 *     (properties+=StepProperty* repeatProps+=RepeatProperty* steps+=Step*)
	 * </pre>
	 */
	protected void sequence_RepeatStep(ISerializationContext context, RepeatStep semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StepProperty returns ScopeProperty
	 *     ScopeProperty returns ScopeProperty
	 *     MapElement returns ScopeProperty
	 *
	 * Constraint:
	 *     value=ID
	 * </pre>
	 */
	protected void sequence_ScopeProperty(ISerializationContext context, ScopeProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FlowServicePackage.Literals.SCOPE_PROPERTY__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FlowServicePackage.Literals.SCOPE_PROPERTY__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getScopePropertyAccess().getValueIDTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SequenceProperty returns SequenceProperty
	 *
	 * Constraint:
	 *     value=STRING
	 * </pre>
	 */
	protected void sequence_SequenceProperty(ISerializationContext context, SequenceProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FlowServicePackage.Literals.SEQUENCE_PROPERTY__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FlowServicePackage.Literals.SEQUENCE_PROPERTY__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSequencePropertyAccess().getValueSTRINGTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Step returns SequenceStep
	 *     SequenceStep returns SequenceStep
	 *
	 * Constraint:
	 *     (properties+=StepProperty* seqProps+=SequenceProperty* steps+=Step*)
	 * </pre>
	 */
	protected void sequence_SequenceStep(ISerializationContext context, SequenceStep semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StepProperty returns TimeoutProperty
	 *     TimeoutProperty returns TimeoutProperty
	 *     MapElement returns TimeoutProperty
	 *
	 * Constraint:
	 *     value=INT
	 * </pre>
	 */
	protected void sequence_TimeoutProperty(ISerializationContext context, TimeoutProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FlowServicePackage.Literals.TIMEOUT_PROPERTY__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FlowServicePackage.Literals.TIMEOUT_PROPERTY__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimeoutPropertyAccess().getValueINTTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MapElement returns TransformStep
	 *     TransformStep returns TransformStep
	 *
	 * Constraint:
	 *     (service=QualifiedServiceName mappings+=MappingBlock*)
	 * </pre>
	 */
	protected void sequence_TransformStep(ISerializationContext context, TransformStep semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TryProperty returns TryProperty
	 *
	 * Constraint:
	 *     value=STRING
	 * </pre>
	 */
	protected void sequence_TryProperty(ISerializationContext context, TryProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FlowServicePackage.Literals.TRY_PROPERTY__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FlowServicePackage.Literals.TRY_PROPERTY__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTryPropertyAccess().getValueSTRINGTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Step returns TryStep
	 *     TryStep returns TryStep
	 *
	 * Constraint:
	 *     ((properties+=StepProperty | tryProps+=TryProperty)* steps+=Step* catches+=CatchStep* finallyBlock=FinallyStep?)
	 * </pre>
	 */
	protected void sequence_TryStep(ISerializationContext context, TryStep semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     InvokeProperty returns ValidateInput
	 *     ValidateInput returns ValidateInput
	 *
	 * Constraint:
	 *     value=BOOL
	 * </pre>
	 */
	protected void sequence_ValidateInput(ISerializationContext context, ValidateInput semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FlowServicePackage.Literals.INVOKE_PROPERTY__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FlowServicePackage.Literals.INVOKE_PROPERTY__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getValidateInputAccess().getValueBOOLTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     InvokeProperty returns ValidateOutput
	 *     ValidateOutput returns ValidateOutput
	 *
	 * Constraint:
	 *     value=BOOL
	 * </pre>
	 */
	protected void sequence_ValidateOutput(ISerializationContext context, ValidateOutput semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FlowServicePackage.Literals.INVOKE_PROPERTY__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FlowServicePackage.Literals.INVOKE_PROPERTY__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getValidateOutputAccess().getValueBOOLTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
}
